<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HajdeRreziko</title>
    <link rel="stylesheet" href="style.css" />
    <link
      rel="icon"
      href="https://skaitech.al/wp-content/uploads/2024/03/icons8-source-code-100.png"
      type="image/png" />
  </head>
  <body>
    <svg style="display: none">
      <path
        id="play"
        fill="none"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="48"
        d="M190.06 414l163.12-139.78a24 24 0 000-36.44L190.06 98c-15.57-13.34-39.62-2.28-39.62 18.22v279.6c0 20.5 24.05 31.56 39.62 18.18z" />
      <path
        id="pause"
        fill="none"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="32"
        d="M176 96h16v320h-16zM320 96h16v320h-16z" />
    </svg>
    <main>
      <ul class="slider">
        <li class="slide">
          <div class="visual">
            <img
              src="https://3dskai.com/wp-content/uploads/2024/10/image9-scaled.jpg"
              alt="Description of image" />
          </div>
          <div class="content">
            <h2 class="title">Sophie</h2>
            <p class="description">
              Frequency: 2π seconds. An enigmatic creature that creates
              fascinating patterns, honoring Sophie Germain's elegant
              mathematics. Her movements tell an eternal story.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
        <li class="slide">
          <div class="visual"></div>
          <div class="content">
            <h2 class="title">René</h2>
            <p class="description">
              Frequency: 2π seconds. A smoky creature moving swiftly along the
              path laid down by the pioneering work of René Descartes embodies
              the guiding principle of the stage, where equations take on a
              timeless beauty.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
        <li class="slide">
          <div class="visual"></div>
          <div class="content">
            <h2 class="title">Ada</h2>
            <p class="description">
              Frequency: 4π seconds. A vibrant organism, weaves intricate
              patterns celebrating the analytical dance of Ada Lovelace's mind.
              Her movements reflect the elegance and precision found in the
              world of algorithms.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
        <li class="slide">
          <div class="visual"></div>
          <div class="content">
            <h2 class="title">Doug</h2>
            <p class="description">
              Frequency: π seconds. A dynamic creature, navigates its realm with
              the agility reminiscent of Douglas Engelbart's inventive spirit.
              His swift movements echo the groundbreaking innovations in
              computer interface design.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
        <li class="slide">
          <div class="visual"></div>
          <div class="content">
            <h2 class="title">Iannis</h2>
            <p class="description">
              Frequency: 2π seconds. A visionary creator, conjures abstract
              patterns reflecting on the mathematical and artistic brilliance of
              Iannis Xenakis. His dance weaves a tapestry that transcends the
              boundaries between mathematics and art.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
        <li class="slide">
          <div class="visual"></div>
          <div class="content">
            <h2 class="title">Umar</h2>
            <p class="description">
              Frequency: 4π seconds. A luminous figure, commemorating the
              profound insights of the Persian polymath Umar Khayyam. His
              graceful movements hint at the mesmerising beauty of what the
              human mind can create.
            </p>
            <button class="more ripple">
              <div class="icon" role="button">
                <svg viewBox="0 0 512 512">
                  <use xlink:href="#play"></use>
                </svg>
              </div>
            </button>
          </div>
        </li>
      </ul>
      <nav class="nav">
        <div class="btn ripple next">
          <div class="icon" role="button">
            <svg viewBox="0 0 512 512">
              <path
                fill="none"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="48"
                d="M268 112l144 144-144 144M392 256H100"></path>
            </svg>
          </div>
        </div>
      </nav>
    </main>
  </body>

  <script>
    let dpr = Math.max(1, window.devicePixelRatio);

    const vertexSource = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

in vec4 position;

void main(void) {
gl_Position = position;
}
`;

    function compile(shader, source) {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
      }
    }

    let canvas,
      gl,
      shaders = [],
      programs = [],
      vertices,
      buffer;

    function setup() {
      canvas = document.createElement("canvas");

      gl = canvas.getContext("webgl2");
      const vs = gl.createShader(gl.VERTEX_SHADER);

      compile(vs, vertexSource);

      shaders = Array.from(
        document.querySelectorAll("script[type='x-shader/x-fragment']")
      );
      programs = shaders.map(() => gl.createProgram());

      for (let i = 0; i < shaders.length; i++) {
        let addr = gl.createShader(gl.FRAGMENT_SHADER);
        let program = programs[i];

        compile(addr, shaders[i].textContent);
        gl.attachShader(program, vs);
        gl.attachShader(program, addr);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
        }
      }

      vertices = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];

      buffer = gl.createBuffer();

      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );

      for (const program of programs) {
        const position = gl.getAttribLocation(program, "position");

        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        // uniforms come here...
        program.resolution = gl.getUniformLocation(program, "resolution");
        program.time = gl.getUniformLocation(program, "time");
      }
    }

    function draw(now, program) {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // uniforms come here...
      gl.uniform2f(program.resolution, canvas.width, canvas.height);
      gl.uniform1f(program.time, now * 1e-3);

      gl.drawArrays(gl.TRIANGLES, 0, vertices.length * 0.5);
    }

    let running = false,
      then = 0,
      af = null;

    function loop(now, index) {
      if (running) {
        draw(now + then, programs[index]);
        af = requestAnimationFrame((t) => loop(t, index));
      } else {
        then = now;
        cancelAnimationFrame(af);
      }
    }

    function removeCanvas() {
      const canvas = document.querySelector("canvas");
      running = false;

      if (canvas) {
        canvas.remove();
      }
    }

    function setXOff(slider, value) {
      if (!slider) {
        slider = document.querySelector(".slider");
      }

      slider.style.setProperty("--x-off", `${value}%`);
    }

    function hookEvents() {
      const slider = document.querySelector(".slider");

      // The primary navigation buttons
      function activate(e) {
        const items = document.querySelectorAll(".slide");
        if (e.target.closest(".nav")) {
          setXOff(slider, 0);

          setTimeout(
            () => {
              e.target.matches(".next") && slider.append(items[0]);
              e.target.matches(".prev") &&
                slider.prepend(items[items.length - 1]);

              // Cleanup
              removeCanvas();
              document
                .querySelectorAll(".slide .more use")
                .forEach((p) => p.setAttribute("xlink:href", "#play"));
            },
            running ? 1000 : 0
          );
        }
      }

      // Allow swiping on mobile
      let sliding = false;
      let origX = 0;

      function slide(e) {
        if (!sliding) return;

        const { touches } = e;
        const first = touches[0];
        const val = first.screenX - origX;

        setXOff(slider, Math.max(-50, Math.min(50, val)));

        if (val < -50) {
          sliding = false;
          setXOff(slider, 0);
          document.querySelector(".next").click();
        } else if (val > 50) {
          sliding = false;
          setXOff(slider, 0);
          document.querySelector(".prev").click();
        }
      }

      document.addEventListener("click", activate);
      document.addEventListener("touchmove", slide);
      document.addEventListener("touchstart", (e) => {
        if (running) return;
        sliding = true;
        origX = e.touches[0].screenX;
      });
      document.addEventListener("touchend", () => {
        if (running) return;
        sliding = false;
        setXOff(null, 0);
      });

      document.addEventListener("keydown", (e) => {
        const items = document.querySelectorAll(".slide");

        if (e.key === "ArrowRight") {
          document.querySelector(".next").click();
        } else if (e.key === "ArrowLeft") {
          document.querySelector(".prev").click();
        } else if (e.key === " ") {
          const button = items[1].querySelector(".more");
          button.click();
        }
      });

      function setupPlayButton() {
        const listItems = document.querySelectorAll(".slide");

        for (const item of listItems) {
          const button = item.querySelector(".more");

          button.addEventListener("click", (e) => {
            const slide = e.target.closest(".slide");
            running = !running;

            // Toggle the play/pause icon
            button
              .querySelector("use")
              .setAttribute("xlink:href", running ? "#pause" : "#play");

            if (!running) {
              // Bring back the thumbnails
              setXOff(slider, 0);
              return;
            }

            // Hide the thumbnails
            setXOff(slider, 100);

            if (slide.querySelector("canvas")) {
              running = true;
              loop(0, slide.dataset.shaderIndex);
            } else {
              // Set up the canvas and start the animation
              animate(slide);
            }
          });
        }
      }

      setupPlayButton();
    }

    function animate(slide) {
      const shaderIndex = slide.dataset.shaderIndex;
      const visual = slide.querySelector(".visual");

      resizeInner();
      running = true;
      loop(0, shaderIndex);
      visual.append(canvas);
    }

    async function init() {
      console.clear();
      hookEvents();
      setup();
      resize();

      // Instead of rendering shaders to background images, just set a static image
      const slides = document.querySelectorAll(".slide");
      slides.forEach((slide) => {
        const img = slide.querySelector("img");
        if (img) {
          slide.style.backgroundImage = `url(${img.src})`;
        }
      });
    }

    async function regenerateImagesWithFullResolution(all = false) {
      return new Promise((resolve) => {
        const slides = document.querySelectorAll(".slide");

        resize();

        for (const slide of slides) {
          const shaderIndex = slide.dataset.shaderIndex;

          // Skip the first two shaders in the initial run (if all is false)
          // since they are already rendered with full resolution
          if (!all && shaderIndex < 2) continue;
          requestAnimationFrame(() => renderBackground(slide));
        }

        resolve();
      });
    }

    function renderBackground(slide) {
      const shaderIndex = slide.dataset.shaderIndex;

      draw(0, programs[shaderIndex]);

      const img = canvas.toDataURL();

      slide.style.backgroundImage = `url(${img})`;
      slide.dataset.rerendered = `${canvas.width}x${canvas.height}`;
      slide.classList.toggle("rerendered"); // help certain browsers to update the background image
    }

    function size(width, height) {
      canvas.width = width;
      canvas.height = height;

      gl.viewport(0, 0, width, height);
    }

    function resizeInner() {
      const { innerWidth: width, innerHeight: height } = window;

      size(width * dpr, height * dpr);
    }

    function resize() {
      const { width, height } = window.screen;

      size(width * dpr, height * dpr);
    }

    window.onresize = () => {
      resizeInner();

      if (running) return;

      // Run the shader animation on the current slide in order to
      // adjust to the new resolution
      document.querySelectorAll(".slide").forEach((slide) => {
        if (slide.querySelector("canvas")) {
          running = true;
          loop(0, slide.dataset.shaderIndex);
          running = false;
        }
      });
    };

    window.onorientationchange = async () => {
      // Regenerate the images with the new resolution
      resize();
      await regenerateImagesWithFullResolution(true);
    };

    window.addEventListener("load", async () => await init());
  </script>
</html>
